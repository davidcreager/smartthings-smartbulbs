{"version":3,"sources":["webpack:///webpack/bootstrap e913dbf04f96e4e566bf","webpack:///./index.js"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;ACtCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,OAAM;AACN,MAAK;AACL;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,KAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,G","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e913dbf04f96e4e566bf\n **/","module.exports = function (Promise) {\n\tfunction isFunction (obj) {\n\t\treturn 'function' == typeof obj || obj instanceof ExtendedMethod;\n\t}\n\n\tfunction deferPromise (Promise)  {\n\t\tvar result = {};\n\t\tresult.promise = new Promise(function(resolve, reject) {\n\t\t\tresult.resolve = function(value) {\n\t\t\t\tresolve(value);\n\t\t\t};\n\t\t\tresult.reject = function(value) {\n\t\t\t\treject(value);\n\t\t\t};\n\t\t});\n\t\treturn result;\n\t}\n\n\tfunction ExtendedMethod (name, func, superFunc) {\n\t\tthis.name = name;\n\t\tthis.func = func;\n\t\tthis.superFunc = superFunc;\n\t}\n\n\tfunction makeMethod (func, scope, name) {\n\t\tvar superFunc = (scope.prototype || scope)[name];\n\n\t\tif (!isFunction(func) || !isFunction(superFunc)) {\n\t\t\treturn func;\n\t\t} else {\n\t\t\treturn new ExtendedMethod(name, func, superFunc);\n\t\t}\n\t}\n\n\tfunction mapPseudoArgsToMethod (func, scope, name, params, superMethod) {\n\t\tfunction mapArgsArray (args, actualArgsArray) {\n\t\t\tfor (var param in params) {\n\t\t\t\tif (typeof params[param] !== 'string') continue;\n\n\t\t\t\tif (params[param] === '$self') {\n\t\t\t\t\targs.push(scope);\n\t\t\t\t} else if (params[param] === '$class') {\n\t\t\t\t\t\targs.push(scope.__class__);\n\t\t\t\t} else if (params[param] === '$super') {\n\t\t\t\t\tif (!superMethod) throw new Error('$super argument for \"' + name + '\" has no super method');\n\t\t\t\t\targs.push(superMethod);\n\t\t\t\t} else if (params[param].substr(0,1) !== '$') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ensure that config object is an object\n\t\t\tif (params.indexOf('$config') !== -1) actualArgsArray[0] = actualArgsArray[0] || {};\n\t\t}\n\n\t\treturn function () {\n\t\t\tvar args = [],\n\t\t\t\tactualArgsArray = Array.prototype.slice.call(arguments);\n\n\t\t\tif (params.indexOf('$deferred') !== -1) {\n\t\t\t\tvar index = params.indexOf('$deferred');\n\n\t\t\t\tif (index !== 0) throw new Error('$deferred argument on the \"' + name + '\" method has an arguments index of ' + index + ' and needs to be 0');\n\n\t\t\t\tvar resolver = deferPromise(Promise);\n\n\t\t\t\targs.push(resolver);\n\n\t\t\t\tmapArgsArray(args, actualArgsArray);\n\n\t\t\t\targs = args.concat(actualArgsArray);\n\n\t\t\t\tif (func.constructor.name === 'GeneratorFunction') {\n\t\t\t\t\tPromise.coroutine(func).apply(scope, args).then(null, function (error) {\n\t\t\t\t\t\tresolver.reject(error);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tfunc.apply(scope, args);\n\t\t\t\t}\n\n\t\t\t\treturn resolver.promise;\n\t\t\t} else {\n\t\t\t\tmapArgsArray(args, actualArgsArray);\n\n\t\t\t\targs = args.concat(actualArgsArray);\n\n\t\t\t\treturn func.apply(scope, args);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction getPseudoArgs (string) {\n\t\tvar args = string.match(/^function\\*? [^\\(]*\\(([a-z0-9_$,\\s]+)\\)/i);\n\t\treturn (args && /\\$(deferred|self|super|config|class)/.test(args[1])) ? args : false;\n\t}\n\n\tfunction mapMethod (func, scope, name, superMethod) {\n\t\tvar funcString = func.toString(),\n\t\t\targs = getPseudoArgs(funcString);\n\n\t\tif (args) {\n\t\t\targs = args[1].replace(/\\s/g, '').split(',');\n\n\t\t\treturn mapPseudoArgsToMethod(func, scope, name, args, superMethod);\n\t\t} else if (func instanceof ExtendedMethod) {\n\t\t\tvar superFunc,\n\t\t\t\tcurrent = func.superFunc,\n\t\t\t\tchain = [];\n\n\t\t\twhile (current instanceof ExtendedMethod) {\n\t\t\t\tchain.push(current);\n\t\t\t\tcurrent = current.superFunc instanceof ExtendedMethod ? current.superFunc : null;\n\t\t\t}\n\n\t\t\tif (chain.length) {\n\t\t\t\tchain.reverse().forEach(function (current) {\n\t\t\t\t\tvar superSuperFunc = mapMethod(current.superFunc, scope, current.name, superFunc);\n\t\t\t\t\tsuperFunc = mapMethod(current.func, scope, current.name, superSuperFunc);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsuperFunc = func.superFunc;\n\t\t\t}\n\n\t\t\tif (!getPseudoArgs(String(superFunc))) superFunc = superFunc.bind(scope);\n\n\t\t\tsuperFunc = mapMethod(superFunc, scope, name);\n\n\t\t\treturn mapMethod(func.func, scope, name, superFunc);\n\t\t} else {\n\t\t\treturn func.bind(scope);\n\t\t}\n\t}\n\n\tfunction makeAndMapMethod (func, scope, name) {\n\t\tscope[name] = makeMethod(func, scope, name);\n\t\treturn isFunction(scope[name]) ? mapMethod(scope[name], scope, name) : scope[name];\n\t}\n\n\tfunction addMixins (args) {\n\t\tvar mixins = Array.prototype.slice.call(args, 0, -1),\n\t\t\tproto = args[args.length-1];\n\n\t\tmixins.forEach(function (mixin) {\n\t\t\tfor (var method in mixin) {\n\t\t\t\tif (method === 'initialize') {\n\t\t\t\t\tif (!proto.___mixin_initializers___) proto.___mixin_initializers___ = [];\n\t\t\t\t\tproto.___mixin_initializers___.push(mixin[method]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (typeof proto[method] !== 'undefined') throw new Error('Mixin: \"' + method + '\" collision, cannot override class methods');\n\t\t\t\tproto[method] = mixin[method];\n\t\t\t}\n\t\t});\n\n\t\treturn proto;\n\t}\n\n\tvar Class = function () {};\n\tClass.create = function () {\n\t\tvar Self = this,\n\t\t\tinstance = function (_Class) {\n\t\t\t\tvar self = this;\n\n\t\t\t\tself.reopen = function (methods) {\n\t\t\t\t\tfor (var method in methods) {\n\t\t\t\t\t\tself[method] = makeAndMapMethod(methods[method], self, method);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (_Class !== Class && isFunction(this.initialize)) {\n\t\t\t\t\tfor (var method in this) {\n\t\t\t\t\t\tif (method.substr(0, 1) !== '$' && method !== '__class__' && isFunction(this[method])) {\n\t\t\t\t\t\t\tthis[method] = mapMethod(this[method], this, method);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.___mixin_initializers___) {\n\t\t\t\t\t\tthis.___mixin_initializers___.forEach(function (initializer) {\n\t\t\t\t\t\t\tinitializer.apply(self);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tdelete this.___mixin_initializers___;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.initialize.apply(this, arguments);\n\t\t\t\t}\n\t\t\t};\n\n\t\t// when Class is passed in the initialize method will not be run\n\t\tinstance.prototype = new Self(Class);\n\n\t\tvar proto = arguments.length > 1 ? addMixins(arguments) : arguments[0];\n\n\t\tfor (var method in proto) {\n\t\t\tinstance.prototype[method] = makeMethod(proto[method], instance, method);\n\t\t}\n\n\t\tfor (method in instance.prototype) {\n\t\t\tif (method.substr(0, 1) === '$') {\n\t\t\t\tinstance[method.substr(1)] = makeAndMapMethod(instance.prototype[method], instance.prototype, method);\n\t\t\t}\n\t\t}\n\n\t\tinstance.prototype.constructor = instance.prototype.__class__ = instance;\n\t\tinstance.extend = this.extend || this.create;\n\t\tinstance.reopen = function (methods) {\n\t\t\tfor (var method in methods) {\n\t\t\t\tif (method === 'initialize') {\n\t\t\t\t\tinstance.prototype[method] = makeMethod(methods[method], instance.prototype, method);\n\t\t\t\t} else {\n\t\t\t\t\tinstance[method] = makeAndMapMethod(methods[method], instance.prototype, '$' + method);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\treturn instance;\n\t};\n\n\treturn Class;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./index.js\n ** module id = 0\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"promise-object.js"}